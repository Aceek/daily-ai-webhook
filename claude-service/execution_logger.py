#!/usr/bin/env python3
"""
Execution Logger - Generates detailed log documents for each workflow execution.

Creates both Markdown (human-readable) and JSON (machine-parsable) logs
for complete traceability of the summarization pipeline.
"""

import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import Any

from pydantic import BaseModel, Field


class ArticleLog(BaseModel):
    """Article data for logging."""

    title: str
    url: str
    source: str
    pub_date: str
    description_preview: str = Field(default="", description="First 100 chars")


class ExecutionMetrics(BaseModel):
    """Metrics captured during execution."""

    prompt_length: int = 0
    response_length: int = 0
    articles_received: int = 0
    duration_seconds: float = 0.0


class ExecutionLog(BaseModel):
    """Complete execution log data."""

    execution_id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    timestamp: datetime = Field(default_factory=datetime.now)
    success: bool = False
    error: str | None = None

    # Input data
    articles: list[ArticleLog] = Field(default_factory=list)

    # Processing data
    prompt_sent: str = ""
    claude_response: str = ""

    # Metrics
    metrics: ExecutionMetrics = Field(default_factory=ExecutionMetrics)


class ExecutionLogger:
    """Handles creation and storage of execution logs."""

    def __init__(self, logs_dir: str = "/app/logs") -> None:
        """Initialize the logger with a logs directory.

        Args:
            logs_dir: Path to the directory where logs will be stored.
        """
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(parents=True, exist_ok=True)

    def _generate_filename(self, execution_log: ExecutionLog) -> str:
        """Generate a filename based on timestamp and execution ID.

        Args:
            execution_log: The execution log to generate filename for.

        Returns:
            Base filename without extension.
        """
        ts = execution_log.timestamp.strftime("%Y-%m-%d_%H-%M-%S")
        return f"{ts}_{execution_log.execution_id}"

    def _format_markdown(self, log: ExecutionLog) -> str:
        """Format execution log as Markdown document.

        Args:
            log: The execution log to format.

        Returns:
            Markdown formatted string.
        """
        status_emoji = "✅" if log.success else "❌"
        status_text = "SUCCESS" if log.success else "FAILED"

        # Build articles table
        articles_table = "| # | Title | Source | Date |\n|---|-------|--------|------|\n"
        for i, article in enumerate(log.articles, 1):
            title_short = (
                article.title[:50] + "..." if len(article.title) > 50 else article.title
            )
            articles_table += f"| {i} | {title_short} | {article.source} | {article.pub_date[:10] if article.pub_date else 'N/A'} |\n"

        md = f"""# Execution Log - {log.timestamp.strftime("%Y-%m-%d %H:%M:%S")}

## Metadata

| Field | Value |
|-------|-------|
| **Execution ID** | `{log.execution_id}` |
| **Timestamp** | {log.timestamp.isoformat()} |
| **Status** | {status_emoji} {status_text} |
| **Duration** | {log.metrics.duration_seconds:.2f}s |
| **Articles Received** | {log.metrics.articles_received} |

"""

        if log.error:
            md += f"""## Error

```
{log.error}
```

"""

        md += f"""## Input Articles

{articles_table}

## Prompt Sent to Claude

<details>
<summary>Click to expand prompt ({log.metrics.prompt_length} characters)</summary>

```
{log.prompt_sent}
```

</details>

## Claude Response

```
{log.claude_response}
```

## Metrics

| Metric | Value |
|--------|-------|
| Prompt Length | {log.metrics.prompt_length:,} chars |
| Response Length | {log.metrics.response_length:,} chars |
| Total Duration | {log.metrics.duration_seconds:.2f}s |

---
*Generated by claude-service v1.0.0*
"""
        return md

    def save(self, execution_log: ExecutionLog) -> tuple[Path, Path]:
        """Save execution log as both Markdown and JSON files.

        Args:
            execution_log: The execution log to save.

        Returns:
            Tuple of (markdown_path, json_path).
        """
        base_filename = self._generate_filename(execution_log)

        # Save Markdown
        md_path = self.logs_dir / f"{base_filename}.md"
        md_content = self._format_markdown(execution_log)
        md_path.write_text(md_content, encoding="utf-8")

        # Save JSON
        json_path = self.logs_dir / f"{base_filename}.json"
        json_content = execution_log.model_dump_json(indent=2)
        json_path.write_text(json_content, encoding="utf-8")

        return md_path, json_path


def create_execution_log(
    articles: list[Any],
    prompt: str,
    response: str,
    duration: float,
    success: bool,
    error: str | None = None,
) -> ExecutionLog:
    """Factory function to create an ExecutionLog from raw data.

    Args:
        articles: List of Article objects from the request.
        prompt: The prompt sent to Claude CLI.
        response: Claude's response.
        duration: Execution duration in seconds.
        success: Whether the execution succeeded.
        error: Error message if failed.

    Returns:
        Populated ExecutionLog instance.
    """
    article_logs = [
        ArticleLog(
            title=a.title,
            url=a.url,
            source=a.source,
            pub_date=a.pub_date,
            description_preview=a.description[:100] if a.description else "",
        )
        for a in articles
    ]

    metrics = ExecutionMetrics(
        prompt_length=len(prompt),
        response_length=len(response),
        articles_received=len(articles),
        duration_seconds=duration,
    )

    return ExecutionLog(
        success=success,
        error=error,
        articles=article_logs,
        prompt_sent=prompt,
        claude_response=response,
        metrics=metrics,
    )
